# -*- coding: utf-8 -*-
"""customeranalytic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gAlvC8SECrRFjGrwVljp6xXj1HEryzVR

---
# **CUSTOMER LIFETIME VALUE (CLV)**
---
# **PART.1**
### **1. Data Preperation**
### **2. Average Order Value**
*   ### average_order_value = total_price /total_transaction 

### **3. Purchase Frequency** 
*   ### total_transaction / total_number_of_customers

### **4. Repeat Rate & Churn Rate** 

### **5. Profit Margin** 
*   ### profit_margin =  total_price * 0.10

### **6. Customer Value** 
*   ### customer_value = average_order_value * purchase_frequency

### **7. Customer Lifetime Value** 
*   ### CLTV = (customer_value / churn_rate) x profit_margin

### **8. Creating Segments**

### **9. Functionalization - I**
# **PART.2**
### **10. Expected Number of Transaction with BG-NBD Model**

### **11. Expected Average Profit with Gamma-Gamma Model**

### **12. Calculation of CLTV with BG-NBD and Gamma-Gamma Model**

### **13. Creating Segments by CLTV**

### **14. Functionalization - II**

---
# **PART.1**
---


# **1. Data Preperation**

### https://archive.ics.uci.edu/ml/datasets/Online+Retail+II

### The dataset named Online Retail II includes the sales of an UK-based online store between 01/12/2009 - 09/12/2011.

## **Variables**
###Information on the data contained in the variables in the dataset is given below.
### **InvoiceNo:** Invoice number. The unique number of each transaction, namely the invoice. Aborted operation if it starts with C.
### **StockCode:** Product code. Unique number for each product.
### **Description:** Product name
### **Quantity:** Number of products. It expresses how many of the products on the invoices have been sold.
### **InvoiceDate:** Invoice date and time.
### **UnitPrice:** Product price (in GBP)
### **CustomerID:** Unique customer number
### **Country:** Country where the customer lives.


---
"""

!pip install lifetimes

import datetime as dt
import pandas as pd
import matplotlib.pyplot as plt
from lifetimes import BetaGeoFitter
from lifetimes import GammaGammaFitter
from lifetimes.plotting import plot_period_transactions
import xtarfile as tarfile
pd.set_option('display.max_columns', None)
pd.set_option('display.width', 500)
pd.set_option('display.float_format', lambda x: '%.4f' % x)
from sklearn.preprocessing import MinMaxScaler

df_ = pd.read_excel("/content/online_retail_II_20092010.xlsx")
df = df_.copy()
df.head()

#Row number of dataframe. Alternative version: len(df)
df.shape[0]

df.isnull().sum()

df = df[~df["Invoice"].str.contains("C", na=False)]

"""### If the invoice contains the letter **"C"**, its type is **Canceled**.

### **Here is a breakdown of how the code works:**


---


### **df["Invoice"].str.contains("C", na=False)** creates a boolean mask that is True for rows where the "Invoice" column contains the letter "C", and False otherwise. The na=False parameter specifies that missing values (NaN) should be treated as False.

### **The tilde ( ~ ) operator negates the boolean mask, so it is True for rows that do not contain the letter "C", and False for rows that do contain the letter "C".**

### The boolean mask is used to index the dataframe df, so df[~ df["Invoice"].str.contains("C", na=False)] returns a new dataframe that only contains rows where the "Invoice" column **does not contain** the letter "C".
"""

df.describe().T

df = df[(df['Quantity'] > 0)]

df.dropna(inplace=True)

df.head(10)

df["TotalPrice"] = df["Quantity"] * df["Price"]

cltv_gb = df.groupby('Customer ID').agg({'Invoice': lambda x: x.nunique(),
                                        'Quantity': lambda x: x.sum(),
                                        'TotalPrice': lambda x: x.sum()})

cltv_gb.columns = ['total_transaction', 'total_unit', 'total_price']

cltv_gb

"""---
# **2. Average Order Value (average_order_value = total_price / total_transaction)**

"""

cltv_gb.head()
cltv_gb["average_order_value"] = cltv_gb["total_price"] / cltv_gb["total_transaction"]
cltv_gb

"""---
# **3. Purchase Frequency (total_transaction / total_number_of_customers)**

"""

cltv_gb["purchase_frequency"] = cltv_gb["total_transaction"] / cltv_gb.shape[0]
cltv_gb

"""---

# **4. Repeat Rate & Churn Rate**

"""

repeat_rate = cltv_gb[cltv_gb["total_transaction"] > 1].shape[0] / cltv_gb.shape[0]

churn_rate = 1 - repeat_rate

"""---

# **5. Profit Margin (profit_margin =  total_price * 0.10)**

"""

cltv_gb['profit_margin'] = cltv_gb['total_price'] * 0.10
cltv_gb

"""# **6. Customer Value (customer_value = average_order_value * purchase_frequency)**"""

cltv_gb['customer_value'] = cltv_gb['average_order_value'] * cltv_gb["purchase_frequency"]
cltv_gb

"""# **7. Customer Lifetime Value (CLTV = (customer_value / churn_rate) x profit_margin)**"""

cltv_gb["cltv"] = (cltv_gb["customer_value"] / churn_rate) * cltv_gb["profit_margin"]

cltv_gb.sort_values(by="cltv", ascending=False)

"""# **8. Creating Segments**"""

cltv_gb.sort_values(by="cltv", ascending=False).tail()

"""
### **Here is a breakdown of how the code works:**


---


### **pd.qcut(cltv_c["cltv"], 4, labels=["D", "C", "B", "A"])** creates four segments of customers based on their CLTV. 
### The pd.qcut() function is used to divide the values of the "cltv" column into four **equal-sized bins**, and the labels parameter is used to assign the labels **"D", "C", "B",** and **"A"** to the four segments in ascending order."""

cltv_gb.sort_values(by="cltv", ascending=False).tail()

cltv_gb["segment"] = pd.qcut(cltv_gb["cltv"], 4, labels=["D", "C", "B", "A"])

cltv_gb.sort_values(by="cltv", ascending=False).head()

cltv_gb.groupby("segment").agg({"count", "mean", "sum"})

cltv_gb.to_csv("cltv_gb.csv")

"""# **9. Functionalization - I**"""

def cltv_Basic(dataframe, profit=0.10):

    # Data Preparation
    dataframe = dataframe[~dataframe["Invoice"].str.contains("C", na=False)]
    dataframe = dataframe[(dataframe['Quantity'] > 0)]
    dataframe.dropna(inplace=True)
    dataframe["TotalPrice"] = dataframe["Quantity"] * dataframe["Price"]
    cltv_gb = dataframe.groupby('Customer ID').agg({'Invoice': lambda x: x.nunique(),
                                                   'Quantity': lambda x: x.sum(),
                                                   'TotalPrice': lambda x: x.sum()})
    cltv_gb.columns = ['total_transaction', 'total_unit', 'total_price']
    # avg_order_value
    cltv_gb['avg_order_value'] = cltv_gb['total_price'] / cltv_gb['total_transaction']
    # purchase_frequency
    cltv_gb["purchase_frequency"] = cltv_gb['total_transaction'] / cltv_gb.shape[0]
    # repeat rate & churn rate
    repeat_rate = cltv_gb[cltv_gb.total_transaction > 1].shape[0] / cltv_gb.shape[0]
    churn_rate = 1 - repeat_rate
    # profit_margin
    cltv_gb['profit_margin'] = cltv_gb['total_price'] * profit
    # Customer Value
    cltv_gb['customer_value'] = (cltv_gb['avg_order_value'] * cltv_gb["purchase_frequency"])
    # Customer Lifetime Value
    cltv_gb['cltv'] = (cltv_gb['customer_value'] / churn_rate) * cltv_gb['profit_margin']
    # Segment
    cltv_gb["segment"] = pd.qcut(cltv_gb["cltv"], 4, labels=["D", "C", "B", "A"])

    return cltv_gb

df = df_.copy()
clv_basic = cltv_Basic(df)

clv_basic

"""---
# **PART.2**
---
"""

def outlier_thresholds(dataframe, variable):
    quartile1 = dataframe[variable].quantile(0.01)
    quartile3 = dataframe[variable].quantile(0.99)
    interquantile_range = quartile3 - quartile1
    up_limit = quartile3 + 1.5 * interquantile_range
    low_limit = quartile1 - 1.5 * interquantile_range
    return low_limit, up_limit

"""### **The outlier_thresholds function** calculates the lower and upper limits for identifying outliers based on the interquartile range method for a numerical column in a Pandas dataframe. These limits can be used to identify and remove outliers from the dataset."""

def replace_with_thresholds(dataframe, variable):
    low_limit, up_limit = outlier_thresholds(dataframe, variable)
    #dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit
    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit

"""### The **replace_with_thresholds** function replaces the outliers in a numerical column of a Pandas dataframe with the upper limit obtained using the interquartile range method. This function can be used to preprocess data and remove outliers that may negatively affect the performance of certain machine learning models.
### **dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit** replaces any value in the variable column of the dataframe that is greater than the upper limit with the upper limit. This is done using the loc method of the dataframe to identify the rows where the condition is true and assign the value of up_limit to the variable column.
### **dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit** replaces any value in the variable column of the dataframe that is smaller than the lower limit with the lower limit. This is done using the loc method of the dataframe to identify the rows where the condition is true and assign the value of low_limit to the variable column.
"""

df_2 = df_.copy()

replace_with_thresholds(df_2, "Quantity")

replace_with_thresholds(df_2, "Price")

df_2["TotalPrice"] = df_2["Quantity"] * df_2["Price"]

today_date = dt.datetime(2011, 12, 11)

"""---
# **10. Preparation of Lifetime Data Structure**

### **recency:** Time since last purchase. Weekly. (user specific)
### **T:** The age of the customer. Weekly. (how long before the analysis date the first purchase was made)
### **frequency:** tekrar eden toplam satın alma sayısı (frequency>1)
### **monetary:** average earnings per purchase

"""

cltv_gb = df_2.groupby('Customer ID').agg(
    {'InvoiceDate':[lambda InvoiceDate: (InvoiceDate.max() - InvoiceDate.min()).days,
                    lambda InvoiceDate: (today_date - InvoiceDate.min()).days],
     'Invoice'    : lambda Invoice: Invoice.nunique(),
     'TotalPrice' : lambda TotalPrice: TotalPrice.sum()})
cltv_gb

#Here, cltv_gb.columns returns the MultiIndex column, and droplevel(0) drops the first level of the column.
#The resulting column will have a single level of column headers.
cltv_gb.columns = cltv_gb.columns.droplevel(0)

cltv_gb.columns = ['recency', 'T', 'frequency', 'monetary']
cltv_gb["monetary"] = cltv_gb["monetary"] / cltv_gb["frequency"]

cltv_gb = cltv_gb[(cltv_gb['frequency'] > 1)]

cltv_gb["recency"] = cltv_gb["recency"] / 7

cltv_gb["T"] = cltv_gb["T"] / 7

cltv_gb=cltv_gb[cltv_gb['monetary']>0]

"""---
# **11. Establishment of BG-NBD Model**

### In the code snippet you provided, a **Beta-Geometric-Negative Binomial (BG/NBD) model** is being fit to a customer transaction dataset using the lifetimes package in Python. **The model is used to estimate the expected number of future transactions for each customer and the probability that a customer is still "alive" (i.e., still making transactions) at a given point in time.**

## **Here is a breakdown of the code:**
---

### **bgf = BetaGeoFitter(penalizer_coef=0.001)** The penalizer_coef parameter is **set to a small positive value to prevent overfitting** of the model.

### **bgf.fit(cltv_df['frequency'], cltv_df['recency'], cltv_df['T'])** fits the BG/NBD model to the dataset. The frequency column contains the number of repeat transactions made by each customer, the recency column contains the time since the last transaction for each customer, and the T column contains the duration of the observation period for each customer. The fit method estimates the model parameters (including the probability of a customer being "alive" and the expected number of future transactions) using maximum likelihood estimation.

### The resulting fitted **BG/NBD model can be used to make predictions about customer behavior**, such as the expected number of future transactions for a new customer or the probability that a customer will make a purchase in the **NEXT** week. **It can also be used to segment customers based on their transactional behavior and identify high-value customers who are more likely to make repeat purchases.**
"""

betageo = BetaGeoFitter(penalizer_coef=0.001)

betageo.fit(cltv_gb['frequency'],
        cltv_gb['recency'],
        cltv_gb['T'])

"""### **Who are the 10 customers we expect the most to purchase in 1 week?**"""

betageo.conditional_expected_number_of_purchases_up_to_time(1,
                                                        cltv_gb['frequency'],
                                                        cltv_gb['recency'],
                                                        cltv_gb['T']).sort_values(ascending=False).head(10)

betageo.predict(1,
            cltv_gb['frequency'],
            cltv_gb['recency'],
            cltv_gb['T']).sort_values(ascending=False).head(10)

betageo.predict(1,cltv_gb['frequency'],
              cltv_gb['recency'],
              cltv_gb['T']).sum()

cltv_gb["expected_purc_1_week"] = betageo.predict(1,
                                              cltv_gb['frequency'],
                                              cltv_gb['recency'],
                                              cltv_gb['T'])

cltv_gb

"""### **Who are the 10 customers we expect the most to purchase in 1 month?**"""

betageo.predict(4,
            cltv_gb['frequency'],
            cltv_gb['recency'],
            cltv_gb['T']).sort_values(ascending=False).head(10)

cltv_gb["expected_purc_1_month"] = betageo.predict(4,
                                               cltv_gb['frequency'],
                                               cltv_gb['recency'],
                                               cltv_gb['T'])

cltv_gb

betageo.predict(4,
            cltv_gb['frequency'],
            cltv_gb['recency'],
            cltv_gb['T']).sum()

"""### **What is the Expected Number of Sales of the Whole Company in 3 Months?**"""

betageo.predict(4 * 3,
            cltv_gb['frequency'],
            cltv_gb['recency'],
            cltv_gb['T']).sum()

cltv_gb["expected_purc_3_month"] = betageo.predict(4 * 3,
                                               cltv_gb['frequency'],
                                               cltv_gb['recency'],
                                               cltv_gb['T'])
cltv_gb

"""### **Evaluation of Forecast Results**

### **plot_period_transactions** is a method of the lifetimes.plotting module in Python's lifetimes package. It can be used to plot the number of customers who made a certain number of transactions during each time period in the dataset, as well as the expected number of customers who will make each number of transactions during each time period, based on the fitted Beta-Geometric-Negative Binomial distribution.

### This will produce a plot with two bars per time period: 

*   ### BLUE bars represent the **actual number** of customers who made each number of transactions
*   ### RED bars represent the **expected number** of customers who will make each number of transactions

"""

plot_period_transactions(betageo)
plt.show()

"""---
# **12. Establishment of GAMMA-GAMMA Model**

### **GammaGammaFitter** is a class in the lifetimes package in Python that can be used to estimate the parameters of the Gamma-Gamma submodel of the Pareto/NBD model for customer lifetime value (CLV) analysis. The Gamma-Gamma submodel estimates the distribution of the monetary value of each transaction, given that a customer has made a purchase.In another words it is used **to model the variability in the monetary value of customer transactions, given that a customer has made at least one transaction.**

### To use GammaGammaFitter with a lifetimes dataset,** you first need to fit a BetaGeoFitter model to the dataset to estimate the customer "lifetime" parameters** (i.e., the frequency, recency, and age distributions). 
### Once you have fitted the BetaGeoFitter model, you can use it to estimate the customer expected lifetime value and the conditional expected transaction value for each customer. Then, you can use the GammaGammaFitter class to estimate the parameters of the Gamma-Gamma submodel based on the conditional expected transaction values.

## **Here is a breakdown of the code:**
---

### **ggf = GammaGammaFitter(penalizer_coef=0.01)** The penalizer_coef parameter is **set to a small positive value to prevent overfitting** of the model.

### **ggf.fit(cltv_df['frequency'], cltv_df['monetary'])** fits the GammaGamma model to the dataset. 

### After fitting the GammaGammaFitter model, you can use its **conditional_expected_average_profit()** method to estimate the conditional expected transaction value for each customer, and the **expected_average_profit()** method to estimate the overall expected transaction value.

### Here, **cltv_df['expected_average_profit']** will be a new column in the cltv_df DataFrame that contains the estimated conditional expected transaction value for each customer, and expected_transaction_value will be a scalar value representing the estimated overall expected transaction value.
"""

gamma = GammaGammaFitter(penalizer_coef=0.01)

gamma.fit(cltv_gb['frequency'], cltv_gb['monetary'])

gamma.conditional_expected_average_profit(cltv_gb['frequency'],
                                        cltv_gb['monetary']).head(10)

cltv_gb["expected_average_profit"] = gamma.conditional_expected_average_profit(cltv_gb['frequency'],
                                                                             cltv_gb['monetary'])
cltv_gb.sort_values("expected_average_profit", ascending=False).head(10)

"""---
# **13. Calculation of CLTV with BG-NBD and Gamma-Gamma Model**

### The **customer_lifetime_value()** method in the GammaGammaFitter class can be used to estimate the customer lifetime value (CLV) of each customer in the dataset based on the Beta-GeoFitter model and the Gamma-Gamma submodel. 

### This method takes as input the fitted Beta-GeoFitter model (bgf), the frequency, recency, and age(T) data for each customer, the monetary value of each transaction (monetary), the time horizon over which to estimate CLV (in this case, 3 months), the frequency of the data (freq), and the discount rate to use in the estimation.

### Here, bgf is the fitted BetaGeoFitter model object, cltv_df['frequency'], cltv_df['recency'], cltv_df['T'], and cltv_df['monetary'] are Pandas Series containing the frequency, recency, age, and monetary data for each customer in the dataset, time=3 specifies that the CLV should be estimated over a 3-month time horizon, freq="W" specifies that the data is in weekly frequency, and discount_rate=0.01 specifies the discount rate to use in the estimation.
"""

cltv = gamma.customer_lifetime_value(betageo,
                                   cltv_gb['frequency'],
                                   cltv_gb['recency'],
                                   cltv_gb['T'],
                                   cltv_gb['monetary'],
                                   time=3,  # 3 aylık
                                   freq="W",  # T'nin frekans bilgisi.
                                   discount_rate=0.01)

cltv.head()

cltv = cltv.reset_index()

cltv_final = cltv_gb.merge(cltv, on="Customer ID", how="left")
cltv_final.sort_values(by="clv", ascending=False).head(10)

"""# **14. Creating Segments by CLTV**"""

cltv_final["segment"] = pd.qcut(cltv_final["clv"], 4, labels=["D", "C", "B", "A"])
cltv_final

cltv_final.groupby("segment").agg(
    {"count", "mean", "sum"})

"""
# **15. Functionalization - II**"""

def CLTV_BetaGeoGamma(dataframe, month=3):
    # 1. Data Preparation
    dataframe.dropna(inplace=True)
    dataframe = dataframe[~dataframe["Invoice"].str.contains("C", na=False)]
    dataframe = dataframe[dataframe["Quantity"] > 0]
    dataframe = dataframe[dataframe["Price"] > 0]
    #-------------------------------------------------------------------------------------------------------------------------
    replace_with_thresholds(dataframe, "Quantity") # get rid of outliers
    replace_with_thresholds(dataframe, "Price")    # get rid of outliers
    #-------------------------------------------------------------------------------------------------------------------------
    dataframe["TotalPrice"] = dataframe["Quantity"] * dataframe["Price"]
    today_date = dt.datetime(2011, 12, 11)
    #-------------------------------------------------------------------------------------------------------------------------
    cltv_gb = dataframe.groupby('Customer ID').agg(
        {'InvoiceDate': [lambda InvoiceDate: (InvoiceDate.max() - InvoiceDate.min()).days,
                         lambda InvoiceDate: (today_date - InvoiceDate.min()).days],
         'Invoice':      lambda Invoice: Invoice.nunique(),
         'TotalPrice':   lambda TotalPrice: TotalPrice.sum()})

    cltv_gb.columns = cltv_gb.columns.droplevel(0)  # The resulting column will have a single level of column headers.
    cltv_gb.columns = ['recency', 'T', 'frequency', 'monetary']
    cltv_gb["monetary"] = cltv_gb["monetary"] / cltv_gb["frequency"]
    cltv_gb = cltv_gb[(cltv_gb['frequency'] > 1)]
    cltv_gb["recency"] = cltv_gb["recency"] / 7
    cltv_gb["T"] = cltv_gb["T"] / 7
    #-------------------------------------------------------------------------------------------------------------------------
    # 2. Establishment of BG-NBD Model
    betageo = BetaGeoFitter(penalizer_coef=0.001)
    betageo.fit(cltv_gb['frequency'],
            cltv_gb['recency'],
            cltv_gb['T'])

    cltv_gb["expected_purc_1_week"] = betageo.predict(1,
                                                  cltv_gb['frequency'],
                                                  cltv_gb['recency'],
                                                  cltv_gb['T'])

    cltv_gb["expected_purc_1_month"] = betageo.predict(4,
                                                   cltv_gb['frequency'],
                                                   cltv_gb['recency'],
                                                   cltv_gb['T'])

    cltv_gb["expected_purc_3_month"] = betageo.predict(12,
                                                   cltv_gb['frequency'],
                                                   cltv_gb['recency'],
                                                   cltv_gb['T'])
    #-------------------------------------------------------------------------------------------------------------------------
    # 3. Establishing the GAMMA-GAMMA Model
    gamma = GammaGammaFitter(penalizer_coef=0.01)
    gamma.fit(cltv_gb['frequency'], cltv_gb['monetary'])
    cltv_gb["expected_average_profit"] = gamma.conditional_expected_average_profit(cltv_gb['frequency'],
                                                                                 cltv_gb['monetary'])
    #-------------------------------------------------------------------------------------------------------------------------
    # 4. Calculation of CLTV with BG-NBD and GG model
    cltv = gamma.customer_lifetime_value(betageo,
                                       cltv_gb['frequency'],
                                       cltv_gb['recency'],
                                       cltv_gb['T'],
                                       cltv_gb['monetary'],
                                       time=month,             # 3 month
                                       freq="W",               # Frequency information of T
                                       discount_rate=0.01)
    #-------------------------------------------------------------------------------------------------------------------------
    # 5. Creating Segments by CLTV
    cltv = cltv.reset_index()
    cltv_final = cltv_df.merge(cltv, on="Customer ID", how="left")
    cltv_final["segment"] = pd.qcut(cltv_final["clv"], 4, labels=["D", "C", "B", "A"])

    return cltv_final

df = df_.copy()
cltv_final2 = CLTV_BetaGeoGamma(df)
cltv_final2

cltv_final2.to_csv("cltv_prediction.csv")